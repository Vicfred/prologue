{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prologue What's past is prologue. Purpose Prologue is a Full-Stack Web Framework which is ideal for building elegant and high performance web services. Reduce magic. Reduce surprise. Documentation Documentation Index Page Core API Index Page Search Page Full API Index Page Search Page Installation First you should install Nim language which is an elegant and high performance language. Follow the instructions and set environment variables correctly. Then you can use nimble command to install prologue. nimble install prologue Prologue also provides some extensions. You can use logue extension to install all of them. If you just want to install one of them, you can use logue extension module for example logue extension redis . Usage Hello World # app.nim import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" let settings = newSettings () var app = newApp ( settings = settings ) app . addRoute ( \"/\" , hello ) app . run () Run app.nim . Now the server is running at localhost:8080. Another example # app.nim import prologue import prologue / middlewares # Async Function proc home * ( ctx : Context ) {. async .} = resp \"<h1>Home</h1>\" proc helloName * ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" proc doRedirect * ( ctx : Context ) {. async .} = resp redirect ( \"/hello\" ) proc login * ( ctx : Context ) {. async .} = resp loginPage () proc do_login * ( ctx : Context ) {. async .} = resp redirect ( \"/hello/Nim\" ) let settings = newSettings ( appName = \"Prologue\" ) var app = newApp ( settings = settings , middlewares = @[ debugRequestMiddleware () ] ) app . addRoute ( \"/\" , home , @[ HttpGet , HttpPost ] ) app . addRoute ( \"/home\" , home , HttpGet ) app . addRoute ( \"/redirect\" , doRedirect , HttpGet ) app . addRoute ( \"/login\" , login , HttpGet ) app . addRoute ( \"/login\" , do_login , HttpPost , middlewares = @[ debugRequestMiddleware () ] ) app . addRoute ( \"/hello/{name}\" , helloName , HttpGet ) app . run () Run app.nim . Now the server is running at localhost:8080. More examples HelloWorld ToDoList ToDoApp Blog Additional examples repository Extensions If you need more extensions, you can refer to awesome prologue and awesome nim . Donate Thanks for supporting me. buy me a coffee patreon Stars","title":"Introduction"},{"location":"#prologue","text":"What's past is prologue.","title":"Prologue"},{"location":"#purpose","text":"Prologue is a Full-Stack Web Framework which is ideal for building elegant and high performance web services. Reduce magic. Reduce surprise.","title":"Purpose"},{"location":"#documentation","text":"Documentation Index Page Core API Index Page Search Page Full API Index Page Search Page","title":"Documentation"},{"location":"#installation","text":"First you should install Nim language which is an elegant and high performance language. Follow the instructions and set environment variables correctly. Then you can use nimble command to install prologue. nimble install prologue Prologue also provides some extensions. You can use logue extension to install all of them. If you just want to install one of them, you can use logue extension module for example logue extension redis .","title":"Installation"},{"location":"#usage","text":"","title":"Usage"},{"location":"#hello-world","text":"# app.nim import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" let settings = newSettings () var app = newApp ( settings = settings ) app . addRoute ( \"/\" , hello ) app . run () Run app.nim . Now the server is running at localhost:8080.","title":"Hello World"},{"location":"#another-example","text":"# app.nim import prologue import prologue / middlewares # Async Function proc home * ( ctx : Context ) {. async .} = resp \"<h1>Home</h1>\" proc helloName * ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" proc doRedirect * ( ctx : Context ) {. async .} = resp redirect ( \"/hello\" ) proc login * ( ctx : Context ) {. async .} = resp loginPage () proc do_login * ( ctx : Context ) {. async .} = resp redirect ( \"/hello/Nim\" ) let settings = newSettings ( appName = \"Prologue\" ) var app = newApp ( settings = settings , middlewares = @[ debugRequestMiddleware () ] ) app . addRoute ( \"/\" , home , @[ HttpGet , HttpPost ] ) app . addRoute ( \"/home\" , home , HttpGet ) app . addRoute ( \"/redirect\" , doRedirect , HttpGet ) app . addRoute ( \"/login\" , login , HttpGet ) app . addRoute ( \"/login\" , do_login , HttpPost , middlewares = @[ debugRequestMiddleware () ] ) app . addRoute ( \"/hello/{name}\" , helloName , HttpGet ) app . run () Run app.nim . Now the server is running at localhost:8080.","title":"Another example"},{"location":"#more-examples","text":"HelloWorld ToDoList ToDoApp Blog Additional examples repository","title":"More examples"},{"location":"#extensions","text":"If you need more extensions, you can refer to awesome prologue and awesome nim .","title":"Extensions"},{"location":"#donate","text":"Thanks for supporting me. buy me a coffee patreon","title":"Donate"},{"location":"#stars","text":"","title":"Stars"},{"location":"application/","text":"application Prologue object is used to configure the application, do some preparations before requests. The hello world example is suitable for learning Prologue object. startup and shutdown events You can set startup events which executes before the application starts and shutdown events after the application stops. You can read the events document later. serve static files Prologue can serve static files, you can read the staticFile documents later. routes You can add all kinds of routes to route table and read the routes document later. middlewares You can use and write middlewares . upload files you can get the info of uploadFile and save it to disks.","title":"Application"},{"location":"application/#application","text":"Prologue object is used to configure the application, do some preparations before requests. The hello world example is suitable for learning Prologue object.","title":"application"},{"location":"application/#startup-and-shutdown-events","text":"You can set startup events which executes before the application starts and shutdown events after the application stops. You can read the events document later.","title":"startup and shutdown events"},{"location":"application/#serve-static-files","text":"Prologue can serve static files, you can read the staticFile documents later.","title":"serve static files"},{"location":"application/#routes","text":"You can add all kinds of routes to route table and read the routes document later.","title":"routes"},{"location":"application/#middlewares","text":"You can use and write middlewares .","title":"middlewares"},{"location":"application/#upload-files","text":"you can get the info of uploadFile and save it to disks.","title":"upload files"},{"location":"context/","text":"Context Context is initialized when a new request enters. You can get the information of the whole Context when you are writing handlers. You can use attributes of context such as request , response , session and so on. For example, you can get the HTTP method of the request. proc login * ( ctx : Context ) {. async .} = doAssert ctx . request . reqMethod == HttpPost Context utils getPostParams: gets the parameters by HttpPost. getQueryParams: gets the query strings(for example, \"www.google.com/hello?name=12\", name=12 ). getPathParams: gets the route parameters(for example, \"/hello/{name}\"). setResponse: it is handy to make the response of ctx . attachment: attachment is used to specify the file will be downloaded. staticFileResponse: serves static files. getUploadFile: gets the UploadFile from request. save: saves the UploadFile to disk.","title":"Context"},{"location":"context/#context","text":"Context is initialized when a new request enters. You can get the information of the whole Context when you are writing handlers. You can use attributes of context such as request , response , session and so on. For example, you can get the HTTP method of the request. proc login * ( ctx : Context ) {. async .} = doAssert ctx . request . reqMethod == HttpPost","title":"Context"},{"location":"context/#context-utils","text":"getPostParams: gets the parameters by HttpPost. getQueryParams: gets the query strings(for example, \"www.google.com/hello?name=12\", name=12 ). getPathParams: gets the route parameters(for example, \"/hello/{name}\"). setResponse: it is handy to make the response of ctx . attachment: attachment is used to specify the file will be downloaded. staticFileResponse: serves static files. getUploadFile: gets the UploadFile from request. save: saves the UploadFile to disk.","title":"Context utils"},{"location":"downloadfiles/","text":"","title":"Downloadfiles"},{"location":"errorhandler/","text":"Error Handler User-defined error pages When web application encounters some unexpected situations, it may send 404 response to the client. You may want to use user-defined 404 pages, then you can use resp to return 404 response. proc hello ( ctx : Context ) {. async .} = resp \"Something is wrong, please retry.\" , Http404 Prologue also provides an error404 helper function to create a 404 response. proc hello ( ctx : Context ) {. async .} = resp error404 ( headers = ctx . response . headers ) Or use errorPage to create a more descriptive error page. proc hello ( ctx : Context ) {. async .} = resp errorPage ( \"Something is wrong\" ), Http404 Default error handler Users can also set the default error handler. When ctx.response.body is empty, web application will use the default error handler. The basic example with respDefault which is equal to resp errorPage(\"Something is wrong\"), Http404 . proc hello ( ctx : Context ) {. async .} = respDefault Http404 Prologue has registered two error handlers before application starts, namely default404Handler for Http404 and default500Handler for Http500 . You can change them using registerErrorHandler . proc go404 * ( ctx : Context ) {. async .} = resp \"Something wrong!\" , Http404 proc go20x * ( ctx : Context ) {. async .} = resp \"Ok!\" , Http200 proc go30x * ( ctx : Context ) {. async .} = resp \"EveryThing else?\" , Http301 app . registerErrorHandler ( Http404 , go404 ) app . registerErrorHandler ({ Http200 .. Http204 }, go20x ) app . registerErrorHandler ( @[ Http301 , Http304 , Http307 ] , go30x ) If you don't want to use the default Error handler, you could clear the whole error handler table. let settings = newSettings () var app = newApp ( settings = settings , errorHandlerTable = newErrorHandlerTable ()) HTTP 500 handler Http 500 indicates the internal error of the framework. In debug mode( settings.debug = true ), the framework will send the exception msgs to the web browser if the length of error msgs is greater than zero. Otherwise, the framework will use the default error handled which has been registered before the application starts. Users could cover this handler by using their own error handler.","title":"Error Handler"},{"location":"errorhandler/#error-handler","text":"","title":"Error Handler"},{"location":"errorhandler/#user-defined-error-pages","text":"When web application encounters some unexpected situations, it may send 404 response to the client. You may want to use user-defined 404 pages, then you can use resp to return 404 response. proc hello ( ctx : Context ) {. async .} = resp \"Something is wrong, please retry.\" , Http404 Prologue also provides an error404 helper function to create a 404 response. proc hello ( ctx : Context ) {. async .} = resp error404 ( headers = ctx . response . headers ) Or use errorPage to create a more descriptive error page. proc hello ( ctx : Context ) {. async .} = resp errorPage ( \"Something is wrong\" ), Http404","title":"User-defined error pages"},{"location":"errorhandler/#default-error-handler","text":"Users can also set the default error handler. When ctx.response.body is empty, web application will use the default error handler. The basic example with respDefault which is equal to resp errorPage(\"Something is wrong\"), Http404 . proc hello ( ctx : Context ) {. async .} = respDefault Http404 Prologue has registered two error handlers before application starts, namely default404Handler for Http404 and default500Handler for Http500 . You can change them using registerErrorHandler . proc go404 * ( ctx : Context ) {. async .} = resp \"Something wrong!\" , Http404 proc go20x * ( ctx : Context ) {. async .} = resp \"Ok!\" , Http200 proc go30x * ( ctx : Context ) {. async .} = resp \"EveryThing else?\" , Http301 app . registerErrorHandler ( Http404 , go404 ) app . registerErrorHandler ({ Http200 .. Http204 }, go20x ) app . registerErrorHandler ( @[ Http301 , Http304 , Http307 ] , go30x ) If you don't want to use the default Error handler, you could clear the whole error handler table. let settings = newSettings () var app = newApp ( settings = settings , errorHandlerTable = newErrorHandlerTable ())","title":"Default error handler"},{"location":"errorhandler/#http-500-handler","text":"Http 500 indicates the internal error of the framework. In debug mode( settings.debug = true ), the framework will send the exception msgs to the web browser if the length of error msgs is greater than zero. Otherwise, the framework will use the default error handled which has been registered before the application starts. Users could cover this handler by using their own error handler.","title":"HTTP 500 handler"},{"location":"event/","text":"Event Prologue supports both startup and shutdown events. startup events will be only executed once before the main loop. In contrast, shutdown events will be executed once after the main loop. Let's first look at the structure of Event , you can see that Event supports both synchronous and asynchronous closure function pointers. type AsyncEvent * = proc (): Future [ void ] {. closure , gcsafe .} SyncEvent * = proc () {. closure , gcsafe .} Event * = object case async * : bool of true : asyncHandler * : AsyncEvent of false : syncHandler * : SyncEvent You can use initEvent and pass function pointers to create Event . proc initEvent * ( handler : AsyncEvent ): Event {. inline .} = Event ( async : true , asyncHandler : handler ) proc initEvent * ( handler : SyncEvent ): Event {. inline .} = Event ( async : false , syncHandler : handler ) newApp has startup and shutdown parameters. You can pass a sequence of events to newApp . proc newApp * ( settings : Settings , middlewares : sink seq [ HandlerAsync ] = @[] , startup : seq [ Event ] = @[] , shutdown : seq [ Event ] = @[] , errorHandlerTable = DefaultErrorHandler , appData = newStringTable ( mode = modeCaseSensitive )): Prologue = Here is an example for a startup event(A shutdown event has the same usage as a startup event). proc setLoggingLevel () = addHandler ( newConsoleLogger ()) logging . setLogFilter ( lvlInfo ) let event = initEvent ( setLoggingLevel ) var app = newApp ( settings = settings , middlewares = @[ debugRequestMiddleware () ] , startup = @[ event ] )","title":"Event"},{"location":"event/#event","text":"Prologue supports both startup and shutdown events. startup events will be only executed once before the main loop. In contrast, shutdown events will be executed once after the main loop. Let's first look at the structure of Event , you can see that Event supports both synchronous and asynchronous closure function pointers. type AsyncEvent * = proc (): Future [ void ] {. closure , gcsafe .} SyncEvent * = proc () {. closure , gcsafe .} Event * = object case async * : bool of true : asyncHandler * : AsyncEvent of false : syncHandler * : SyncEvent You can use initEvent and pass function pointers to create Event . proc initEvent * ( handler : AsyncEvent ): Event {. inline .} = Event ( async : true , asyncHandler : handler ) proc initEvent * ( handler : SyncEvent ): Event {. inline .} = Event ( async : false , syncHandler : handler ) newApp has startup and shutdown parameters. You can pass a sequence of events to newApp . proc newApp * ( settings : Settings , middlewares : sink seq [ HandlerAsync ] = @[] , startup : seq [ Event ] = @[] , shutdown : seq [ Event ] = @[] , errorHandlerTable = DefaultErrorHandler , appData = newStringTable ( mode = modeCaseSensitive )): Prologue = Here is an example for a startup event(A shutdown event has the same usage as a startup event). proc setLoggingLevel () = addHandler ( newConsoleLogger ()) logging . setLogFilter ( lvlInfo ) let event = initEvent ( setLoggingLevel ) var app = newApp ( settings = settings , middlewares = @[ debugRequestMiddleware () ] , startup = @[ event ] )","title":"Event"},{"location":"faq/","text":"FAQ If you use Linux or MacOS, you can use --threads:on to enable the multi-threads HTTP server. If you use windows and want to use multi-threads HTTP server, make sure use latest Nim devel version and enable --threads:on . In this situation, you can use -d:usestd to use asynchttpserver . Notes that multi threads may be slower than single-thread in windows! If you want to benchmark prologue or release you programs, make sure set settings.debug = false. let # debug attributes must be false env = loadPrologueEnv ( \".env\" ) settings = newSettings ( appName = env . getOrDefault ( \"appName\" , \"Prologue\" ), debug = false , port = Port ( env . getOrDefault ( \"port\" , 8080 )), staticDirs = [ env . get ( \"staticDir\" ) ] , secretKey = env . getOrDefault ( \"secretKey\" , \"\" ) ) or in .env file, set debug = false . # Don't commit this to source control. # Eg. Make sure \".env\" in your \".gitignore\" file. debug = false # change this port = 8080 appName = HelloWorld staticDir =/ static secretKey = Pr435ol67ogue There are two ways to disable logging messages: (1) set settings.debug = false (2) set a startup event proc setLoggingLevel () = addHandler ( newConsoleLogger ()) logging . setLogFilter ( lvlInfo ) let event = initEvent ( setLoggingLevel ) var app = newApp ( settings = settings , middlewares = @[ debugRequestMiddleware () ] , startup = @[ event ] )","title":"FAQ"},{"location":"faq/#faq","text":"If you use Linux or MacOS, you can use --threads:on to enable the multi-threads HTTP server. If you use windows and want to use multi-threads HTTP server, make sure use latest Nim devel version and enable --threads:on . In this situation, you can use -d:usestd to use asynchttpserver . Notes that multi threads may be slower than single-thread in windows! If you want to benchmark prologue or release you programs, make sure set settings.debug = false. let # debug attributes must be false env = loadPrologueEnv ( \".env\" ) settings = newSettings ( appName = env . getOrDefault ( \"appName\" , \"Prologue\" ), debug = false , port = Port ( env . getOrDefault ( \"port\" , 8080 )), staticDirs = [ env . get ( \"staticDir\" ) ] , secretKey = env . getOrDefault ( \"secretKey\" , \"\" ) ) or in .env file, set debug = false . # Don't commit this to source control. # Eg. Make sure \".env\" in your \".gitignore\" file. debug = false # change this port = 8080 appName = HelloWorld staticDir =/ static secretKey = Pr435ol67ogue There are two ways to disable logging messages: (1) set settings.debug = false (2) set a startup event proc setLoggingLevel () = addHandler ( newConsoleLogger ()) logging . setLogFilter ( lvlInfo ) let event = initEvent ( setLoggingLevel ) var app = newApp ( settings = settings , middlewares = @[ debugRequestMiddleware () ] , startup = @[ event ] )","title":"FAQ"},{"location":"headers/","text":"Headers Prologue provides two types of headers . One is the headers of request which carries information from the client. The other is the headers of response which carries information sent to the client. The headers of the request The client will send headers to our HTTP server. You may want to check whether some keys are in the headers. If existing, you could get the values of them. The return type of ctx.request.getHeader is seq[string] . You often only need the first element of the sequence. The following code first checks whether the key exists in headers. If true, retrieve the sequence of values and display them in the browser. proc hello ( ctx : Context ) {. async .} = if ctx . request . hasHeader ( \"cookie\" ): let values = ctx . request . getHeader ( \"cookie\" ) resp $ values elif ctx . request . hasHeader ( \"content-type\" ): let values = ctx . request . getHeaderOrDefault ( \"content\" ) resp $ values The headers of the response Prologue also sends HTTP headers to the client. It uses ResponseHeaders to store them. It has similar API like the headers of the request. First, Prologue initializes ctx.response with initResponseHeaders . Then users could use hasHeader , addHeader or setHeader to do what they want. Notes that, addHeader will append values to existing keys in headers. setHeader will reset the values of key no matter whether key is in the headers. proc hello ( ctx : Context ) {. async .} = ctx . response . addHeader ( \"Content-Type\" , \"text/plain\" ) doAssert ctx . response . getHeader ( \"CONTENT-TYPE\" ) == @[ \"text/html; charset=UTF-8\" , \"text/plain\" ] ctx . response . setHeader ( \"Content-Type\" , \"text/plain\" ) doAssert ctx . response . getHeader ( \"CONTENT-TYPE\" ) == @[ \"text/html; charset=UTF-8\" , \"text/plain\" ]","title":"Headers"},{"location":"headers/#headers","text":"Prologue provides two types of headers . One is the headers of request which carries information from the client. The other is the headers of response which carries information sent to the client.","title":"Headers"},{"location":"headers/#the-headers-of-the-request","text":"The client will send headers to our HTTP server. You may want to check whether some keys are in the headers. If existing, you could get the values of them. The return type of ctx.request.getHeader is seq[string] . You often only need the first element of the sequence. The following code first checks whether the key exists in headers. If true, retrieve the sequence of values and display them in the browser. proc hello ( ctx : Context ) {. async .} = if ctx . request . hasHeader ( \"cookie\" ): let values = ctx . request . getHeader ( \"cookie\" ) resp $ values elif ctx . request . hasHeader ( \"content-type\" ): let values = ctx . request . getHeaderOrDefault ( \"content\" ) resp $ values","title":"The headers of the request"},{"location":"headers/#the-headers-of-the-response","text":"Prologue also sends HTTP headers to the client. It uses ResponseHeaders to store them. It has similar API like the headers of the request. First, Prologue initializes ctx.response with initResponseHeaders . Then users could use hasHeader , addHeader or setHeader to do what they want. Notes that, addHeader will append values to existing keys in headers. setHeader will reset the values of key no matter whether key is in the headers. proc hello ( ctx : Context ) {. async .} = ctx . response . addHeader ( \"Content-Type\" , \"text/plain\" ) doAssert ctx . response . getHeader ( \"CONTENT-TYPE\" ) == @[ \"text/html; charset=UTF-8\" , \"text/plain\" ] ctx . response . setHeader ( \"Content-Type\" , \"text/plain\" ) doAssert ctx . response . getHeader ( \"CONTENT-TYPE\" ) == @[ \"text/html; charset=UTF-8\" , \"text/plain\" ]","title":"The headers of the response"},{"location":"middleware/","text":"Middlewares Write a middleware Middleware is like an onion. s a request -> middlewareA does something -> middlewareB does something -> handler does something -> middlewareB does something -> middlewareA does something -> a response Don't forget await switch(ctx) to enter next middleware or handler. Then you can set global middlewares which are visible to all handlers. Or you can make them only visible to some middlewares. import logging import prologue proc hello ( ctx : Context ) {. async .} = discard proc myDebugRequestMiddleware * ( appName = \"Prologue\" ): HandlerAsync = result = proc ( ctx : Context ) {. async .} = logging . info \"debugRequestMiddleware->begin\" # do something before await switch ( ctx ) # do something after logging . info \"debugRequestMiddleware->End\" var settings = newSettings () app = newApp ( settings = settings , middlewares = @[ myDebugRequestMiddleware () ] ) app . addRoute ( \"/\" , hello , HttpGet , middlewares = @[ myDebugRequestMiddleware () ] ) You can also put some variables in closure environments, but be careful it is error-prone when using multi-threads. You must know the differences between GC options(thread local heap vs shared heap) and what's the use of gcsafe . proc sessionMiddleware (): HandleAsync = var memorySessionTable = newTable [ string , string ] () result = proc ( ctx : Context ) {. async .} = memorySessionTable [ \"test\" ] = \"prologue\" You can put your middleware plugin in collections . Use a middleware prologue also supplies some middleware plugins, you can directly import them. import prologue / middlewares For better compilation time, you could import them directly. import prologue / middlewares / signedcookiesession # or import prologue / middlewares / utils # or import prologue / middlewares / cors","title":"Middleware"},{"location":"middleware/#middlewares","text":"","title":"Middlewares"},{"location":"middleware/#write-a-middleware","text":"Middleware is like an onion. s a request -> middlewareA does something -> middlewareB does something -> handler does something -> middlewareB does something -> middlewareA does something -> a response Don't forget await switch(ctx) to enter next middleware or handler. Then you can set global middlewares which are visible to all handlers. Or you can make them only visible to some middlewares. import logging import prologue proc hello ( ctx : Context ) {. async .} = discard proc myDebugRequestMiddleware * ( appName = \"Prologue\" ): HandlerAsync = result = proc ( ctx : Context ) {. async .} = logging . info \"debugRequestMiddleware->begin\" # do something before await switch ( ctx ) # do something after logging . info \"debugRequestMiddleware->End\" var settings = newSettings () app = newApp ( settings = settings , middlewares = @[ myDebugRequestMiddleware () ] ) app . addRoute ( \"/\" , hello , HttpGet , middlewares = @[ myDebugRequestMiddleware () ] ) You can also put some variables in closure environments, but be careful it is error-prone when using multi-threads. You must know the differences between GC options(thread local heap vs shared heap) and what's the use of gcsafe . proc sessionMiddleware (): HandleAsync = var memorySessionTable = newTable [ string , string ] () result = proc ( ctx : Context ) {. async .} = memorySessionTable [ \"test\" ] = \"prologue\" You can put your middleware plugin in collections .","title":"Write a middleware"},{"location":"middleware/#use-a-middleware","text":"prologue also supplies some middleware plugins, you can directly import them. import prologue / middlewares For better compilation time, you could import them directly. import prologue / middlewares / signedcookiesession # or import prologue / middlewares / utils # or import prologue / middlewares / cors","title":"Use a middleware"},{"location":"parameters/","text":"","title":"Parameters"},{"location":"quickstart/","text":"Quick Start hello world Now Let's begin a quick tour of Prologue . # app.nim import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" let settings = newSettings () var app = newApp ( settings = settings ) app . addRoute ( \"/\" , hello ) app . run () This is a very basic \"Hello Prologue\" example. Run this script, then visit http://localhost:8080 and you will see \"Hello, Prologue!\" in your browser! Here is how it works. First we import prologue to include all things we need in this example(for examples resp macros). Then let's look at hello function. It generates html or plain text or json or something else sent to our HTTP server. The parameter ctx is of Context type. Context carries all things which we can use in our handler in each request. It contains request information from HTTP server, response information which we transfer to HTTP server Correspondingly and other useful attributes. In the body of function, we can find resp macros. resp is handy for generating response we need. It is equal to ctx.response = initResponse(\"<h1>Hello, Prologue!</h1>\") . Next let's configure our application. For this basic example, we use default settings. You can specify parameters of newSettings too. For example change port attribute or set debug flag. Next add route to our application. \"/\" is the URL we can visit in the web browser. Hello is the handler which processes the request from the web browser and sends \"<h1>Hello, Prologue!</h1>\" to the web browser. Finally use nim c -r app.nim to run our application. Visit localhost:8080 , Hello, Prologue! is displayed in your browser. Command line tool logue can be used to initialize your program. Make sure ~/.nimble/bin is in your environment variables. Type command logue init helloworld to initialize a new project. This will create a program structure like this: - helloworld - .env - app.nim - urls.nim - views.nim You must switch to /.../helloworld directory to run app.nim . For example, you can type logue run and open the browser to visit the URL.","title":"QuickStart"},{"location":"quickstart/#quick-start","text":"","title":"Quick Start"},{"location":"quickstart/#hello-world","text":"Now Let's begin a quick tour of Prologue . # app.nim import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" let settings = newSettings () var app = newApp ( settings = settings ) app . addRoute ( \"/\" , hello ) app . run () This is a very basic \"Hello Prologue\" example. Run this script, then visit http://localhost:8080 and you will see \"Hello, Prologue!\" in your browser! Here is how it works. First we import prologue to include all things we need in this example(for examples resp macros). Then let's look at hello function. It generates html or plain text or json or something else sent to our HTTP server. The parameter ctx is of Context type. Context carries all things which we can use in our handler in each request. It contains request information from HTTP server, response information which we transfer to HTTP server Correspondingly and other useful attributes. In the body of function, we can find resp macros. resp is handy for generating response we need. It is equal to ctx.response = initResponse(\"<h1>Hello, Prologue!</h1>\") . Next let's configure our application. For this basic example, we use default settings. You can specify parameters of newSettings too. For example change port attribute or set debug flag. Next add route to our application. \"/\" is the URL we can visit in the web browser. Hello is the handler which processes the request from the web browser and sends \"<h1>Hello, Prologue!</h1>\" to the web browser. Finally use nim c -r app.nim to run our application. Visit localhost:8080 , Hello, Prologue! is displayed in your browser.","title":"hello world"},{"location":"quickstart/#command-line-tool","text":"logue can be used to initialize your program. Make sure ~/.nimble/bin is in your environment variables. Type command logue init helloworld to initialize a new project. This will create a program structure like this: - helloworld - .env - app.nim - urls.nim - views.nim You must switch to /.../helloworld directory to run app.nim . For example, you can type logue run and open the browser to visit the URL.","title":"Command line tool"},{"location":"request/","text":"Request Request contains the information from the HTTP server. You can visit this attribute by using ctx.request . for example, you maybe want to get state from users, you can query the cookies attribute. proc hello ( ctx : Context ) {. async .} = if ctx . request . cookies . hasKey ( \"happy\" ): echo \"Yea, I'm happy\" Request utils request.url: gets the url of the request request.port: gets the port of the request request.path: gets the path of the request. request.reqMethod: gets the HttpMethod of the request. request.contentType: gets the contentType of the request. request.hostName: gets the hostname of the request.","title":"Requests"},{"location":"request/#request","text":"Request contains the information from the HTTP server. You can visit this attribute by using ctx.request . for example, you maybe want to get state from users, you can query the cookies attribute. proc hello ( ctx : Context ) {. async .} = if ctx . request . cookies . hasKey ( \"happy\" ): echo \"Yea, I'm happy\"","title":"Request"},{"location":"request/#request-utils","text":"request.url: gets the url of the request request.port: gets the port of the request request.path: gets the path of the request. request.reqMethod: gets the HttpMethod of the request. request.contentType: gets the contentType of the request. request.hostName: gets the hostname of the request.","title":"Request utils"},{"location":"response/","text":"Response Respond by types You can specify different responses by types. - htmlResponse -> HTML format - plainTextResponse -> Plain Text format - jsonResponse -> Json format Respond by error code error404 -> return 404 redirect -> return 301 and redirect to a new page abort -> return 401 Other utils You can set the cookie and header of the response. SetCookie : sets the cookie of the response. DeleteCookie : deletes the cookie of the response. setHeader : sets the header values of the response. addHeader : adds header values to the existing HttpHeaders . Send user-defined response Prologue framework will automatically send the final response to the client. You just need to set the attributes of response. It also supports sending response by yourself. For example you can use ctx.respond to send data to the client. proc sendResponse ( ctx : Context ) {. async .} = await ctx . respond ( Http200 , \"data\" ) But this will leads that \"data\" message is sent twice, it's ok for some situations. For example, you may want to send another message, you can change the body of the response. proc sendResponse ( ctx : Context ) {. async .} = await ctx . respond ( Http200 , \"data\" ) ctx . response . body = \"message\" First this handler will send \"data\" to the client, then the handler will send \"message\" to the client. However, this may be not the intended behaviour. You want to make sure when you send response by yourself, the framework shouldn't handle the response anymore. You can set the handled attributes of context to true. Now the framework won't handle ctx.response any more, even the error handler won't work. Only \"data\" message is sent to the client. proc sendResponse ( ctx : Context ) {. async .} = await ctx . respond ( Http200 , \"data\" ) ctx . handled = true ctx . response . code = Http500 ctx . response . body = \"message\"","title":"Response"},{"location":"response/#response","text":"","title":"Response"},{"location":"response/#respond-by-types","text":"You can specify different responses by types. - htmlResponse -> HTML format - plainTextResponse -> Plain Text format - jsonResponse -> Json format","title":"Respond by types"},{"location":"response/#respond-by-error-code","text":"error404 -> return 404 redirect -> return 301 and redirect to a new page abort -> return 401","title":"Respond by error code"},{"location":"response/#other-utils","text":"You can set the cookie and header of the response. SetCookie : sets the cookie of the response. DeleteCookie : deletes the cookie of the response. setHeader : sets the header values of the response. addHeader : adds header values to the existing HttpHeaders .","title":"Other utils"},{"location":"response/#send-user-defined-response","text":"Prologue framework will automatically send the final response to the client. You just need to set the attributes of response. It also supports sending response by yourself. For example you can use ctx.respond to send data to the client. proc sendResponse ( ctx : Context ) {. async .} = await ctx . respond ( Http200 , \"data\" ) But this will leads that \"data\" message is sent twice, it's ok for some situations. For example, you may want to send another message, you can change the body of the response. proc sendResponse ( ctx : Context ) {. async .} = await ctx . respond ( Http200 , \"data\" ) ctx . response . body = \"message\" First this handler will send \"data\" to the client, then the handler will send \"message\" to the client. However, this may be not the intended behaviour. You want to make sure when you send response by yourself, the framework shouldn't handle the response anymore. You can set the handled attributes of context to true. Now the framework won't handle ctx.response any more, even the error handler won't work. Only \"data\" message is sent to the client. proc sendResponse ( ctx : Context ) {. async .} = await ctx . respond ( Http200 , \"data\" ) ctx . handled = true ctx . response . code = Http500 ctx . response . body = \"message\"","title":"Send user-defined response"},{"location":"route/","text":"Route Route is the core of web framework. Static Route Registering handler hello by specifying path, HTTP methods and middlewares. HttpGet is the default HTTP methods. If you have registered a handler with HttpGet , Prologue will automatically register HttpHead for this handler. # handler proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" app . addRoute ( \"/hello\" , hello ) You can also use seq[httpMetod] to register the same handler but supports multiple HTTP methods. # handler proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" app . addRoute ( \"/hello\" , hello , @[ HttpGet , HttpPost ] ) Parameters Route Prologue supports parameters route. You can use getPathParams to get named arguments. proc helloName * ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" app . addRoute ( \"/hello/{name}\" , helloName , HttpGet ) Regex Route Prologue supports regex route. proc articles * ( ctx : Context ) {. async .} = resp $ ctx . getPathParams ( \"num\" , 1 ) app . addRoute ( re\"/post(?P<num>[\\d]+)\" , articles , HttpGet )","title":"Route"},{"location":"route/#route","text":"Route is the core of web framework.","title":"Route"},{"location":"route/#static-route","text":"Registering handler hello by specifying path, HTTP methods and middlewares. HttpGet is the default HTTP methods. If you have registered a handler with HttpGet , Prologue will automatically register HttpHead for this handler. # handler proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" app . addRoute ( \"/hello\" , hello ) You can also use seq[httpMetod] to register the same handler but supports multiple HTTP methods. # handler proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" app . addRoute ( \"/hello\" , hello , @[ HttpGet , HttpPost ] )","title":"Static Route"},{"location":"route/#parameters-route","text":"Prologue supports parameters route. You can use getPathParams to get named arguments. proc helloName * ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" app . addRoute ( \"/hello/{name}\" , helloName , HttpGet )","title":"Parameters Route"},{"location":"route/#regex-route","text":"Prologue supports regex route. proc articles * ( ctx : Context ) {. async .} = resp $ ctx . getPathParams ( \"num\" , 1 ) app . addRoute ( re\"/post(?P<num>[\\d]+)\" , articles , HttpGet )","title":"Regex Route"},{"location":"session/","text":"Session The session helps with storing users' state. Session based on signed cookie This session is based on signed cookie. It is not safe . You must not use it to store sensitive or important info except for testing. Prologue provides sessionMiddleware to you. Usage First you should register sessionMiddleware in global middlewares or handler's middlewares. var app = newApp ( settings = settings , middlewares = @[ sessionMiddleware ( secretKey = secretKey . SecretKey ) ] ) Then you can use session in all handlers. You can set/get/clear session. proc login * ( ctx : Context ) {. async .} = ctx . session [ \"flywind\" ] = \"123\" ctx . session [ \"ordontfly\" ] = \"345\" resp \"<h1>Hello, Prologue!</h1>\" proc logout * ( ctx : Context ) {. async .} = resp $ ctx . session More session examples are in Session and Blog","title":"Session"},{"location":"session/#session","text":"The session helps with storing users' state.","title":"Session"},{"location":"session/#session-based-on-signed-cookie","text":"This session is based on signed cookie. It is not safe . You must not use it to store sensitive or important info except for testing. Prologue provides sessionMiddleware to you.","title":"Session based on signed cookie"},{"location":"session/#usage","text":"First you should register sessionMiddleware in global middlewares or handler's middlewares. var app = newApp ( settings = settings , middlewares = @[ sessionMiddleware ( secretKey = secretKey . SecretKey ) ] ) Then you can use session in all handlers. You can set/get/clear session. proc login * ( ctx : Context ) {. async .} = ctx . session [ \"flywind\" ] = \"123\" ctx . session [ \"ordontfly\" ] = \"345\" resp \"<h1>Hello, Prologue!</h1>\" proc logout * ( ctx : Context ) {. async .} = resp $ ctx . session More session examples are in Session and Blog","title":"Usage"},{"location":"staticfiles/","text":"Static Files Prologue supports serving static files. staticFileResponse You can use staticFileResponse to make a static file response. proc home ( ctx : Context ) {. async .} = await ctx . staticFileResponse ( \"hello.html\" , \"\" ) serve static files You can specify Settings.staticDirs attributes to serve multiple static dirs. staticDirs is of seq[string] type, it contains all the dirs of static files which will be checked in every request. let env = loadPrologueEnv ( \".env\" ) settings = newSettings ( staticDirs = [ env . get ( \"staticDir\" ) ] ) Or set staticDirs directly: let settings = newSettings ( staticDirs = [ \"/static\" , \"/templates\" ] )","title":"Static Files"},{"location":"staticfiles/#static-files","text":"Prologue supports serving static files.","title":"Static Files"},{"location":"staticfiles/#staticfileresponse","text":"You can use staticFileResponse to make a static file response. proc home ( ctx : Context ) {. async .} = await ctx . staticFileResponse ( \"hello.html\" , \"\" )","title":"staticFileResponse"},{"location":"staticfiles/#serve-static-files","text":"You can specify Settings.staticDirs attributes to serve multiple static dirs. staticDirs is of seq[string] type, it contains all the dirs of static files which will be checked in every request. let env = loadPrologueEnv ( \".env\" ) settings = newSettings ( staticDirs = [ env . get ( \"staticDir\" ) ] ) Or set staticDirs directly: let settings = newSettings ( staticDirs = [ \"/static\" , \"/templates\" ] )","title":"serve static files"},{"location":"uploadfile/","text":"Upload Files getUploadFile accepts the name of file input(HTNL) to get the info of file. The function returns the name and contents of the file. For this example, the name is \"file\". < form action = \"upload\" method = \"post\" enctype = \"multipart/form-data\" > < input type = \"file\" name = \"file\" value = \"eva\" > < input type = \"submit\" value = \"Submit\" name = \"submit\" > </ form > getUploadFile only works when you use form parameters and HttpPost method. Context module provides a helper function to save the uploadFile to disks. If you don't specify the name of the file, it will use the origin name from user. proc upload ( ctx : Context ) {. async .} = if ctx . request . reqMethod == HttpGet : await ctx . staticFileResponse ( \"tests/test_uploadFile/upload.html\" , \"\" ) elif ctx . request . reqMethod == HttpPost : let file = ctx . getUploadFile ( \"file\" ) file . save ( \"tests/test_uploadFile\" ) file . save ( \"tests/test_uploadFile\" , \"set.txt\" ) resp fmt\"<html><h1>{file.filename}</h1><p>{file.body}</p></html>\" The full example","title":"Upload Files"},{"location":"uploadfile/#upload-files","text":"getUploadFile accepts the name of file input(HTNL) to get the info of file. The function returns the name and contents of the file. For this example, the name is \"file\". < form action = \"upload\" method = \"post\" enctype = \"multipart/form-data\" > < input type = \"file\" name = \"file\" value = \"eva\" > < input type = \"submit\" value = \"Submit\" name = \"submit\" > </ form > getUploadFile only works when you use form parameters and HttpPost method. Context module provides a helper function to save the uploadFile to disks. If you don't specify the name of the file, it will use the origin name from user. proc upload ( ctx : Context ) {. async .} = if ctx . request . reqMethod == HttpGet : await ctx . staticFileResponse ( \"tests/test_uploadFile/upload.html\" , \"\" ) elif ctx . request . reqMethod == HttpPost : let file = ctx . getUploadFile ( \"file\" ) file . save ( \"tests/test_uploadFile\" ) file . save ( \"tests/test_uploadFile\" , \"set.txt\" ) resp fmt\"<html><h1>{file.filename}</h1><p>{file.body}</p></html>\" The full example","title":"Upload Files"}]}